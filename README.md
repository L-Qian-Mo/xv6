一、实践背景
本实践基于 MIT xv6（x86 版本），围绕操作系统从 bootloader 到内核 main 函数的完
整启动流程展开，配合视频学习 bootblock、bootasm.S、bootmain.c、entry.S 以及内
核页表初始化过程。
二、实践目标
1.理解 xv6 启动链路：bootblock → bootasm.S → bootmain.c → entry.S → main()
2.掌握汇编与 C 在启动阶段的协作方式
3.理解 ELF 内核镜像加载过程
4.学会在关键启动节点插入调试信息
5.熟练使用 Git 进行 fork、commit 和 push
三、实践任务内容
1.实验准备——搭建环境
本次实验经历多轮环境适配，最终确定稳定的实验环境：
初次尝试WSL2环境：因WSL2下载失败放弃该方案；
二次尝试VirtualBox+Ubuntu：因 VirtualBox 的硬件虚拟化强化功能配置失败，无法正常运行QEMU，放弃该方案；
最终方案：VMware Workstation + Ubuntu 20.04 LTS 虚拟机（匹配视频教程版本），通过 VSCode 远程连接虚拟机编辑代码，配置共享文件夹实现 Windows 与虚拟机的代码同步，完成 xv6 编译运行的基础环境搭建。
2.任务1：Fork并成功启动xv6
(1)操作步骤：
    从 MIT 官方仓库 fork xv6 源码到个人 Git 仓库；
    在vscode中实现克隆到本地；
    编译启动：执行 make qemu-nox，成功进入 xv6 命令行界面（启动界面见截图：启动.png）。
(2)关键验证：确认 xv6 启动后可执行 ls、echo 等基础命令，证明环境与源码无异常。
3.任务2：启动流程注释
详情可以看具体文档
bootasm.S、bootmain.c、entry.S
4.任务3：启动过程可视化（核心任务）
(1)初始尝试：VSCode 日志断点
    方案：尝试通过 VSCode 的 “日志断点” 功能自动输出节点日志；
    结果：失败，原因是 xv6 启动阶段无完整 C 运行时环境，VSCode 断点机制无法适配汇编代码执行阶段。
(2)最终方案：QEMU + GDB 调试（核心）
    编写调试脚本 xv6_debug.gdb
    调试操作：
        启动 QEMU 调试模式：make qemu-nox-gdb；
        执行 GDB 脚本：gdb-multiarch kernel -x xv6_debug.gdb；
        程序停在 0x7d91（跳转 entry 前），输入 si 单步执行到 entry 断点，手动确认日志输出；
    最终输出（见截图：打印输出.png）
四、个人总结
1.我成功适配了VMware Workstation+Ubuntu 20.04实验环境，熟练完成了VSCode远程连接、共享文件夹同步、QEMU与GDB-multiarch工具的安装配置等操作；在调试环节，我掌握了QEMU + GDB调试xv6内核的核心方法，能灵活运用软件断点、硬件断点、单步执行等命令，有效排查并解决了断点失效、日志吞掉等调试难题；版本管理方面，我精通Git的fork、clone、commit、push等完整流程，实现了xv6源码的规范化版本控制，确保代码可追溯、可复用。
2.我彻底厘清了xv6从bootblock → bootasm.S → bootmain.c → entry.S → main() 的完整启动链路，明确了汇编代码在搭建执行环境、切换地址空间中的基础作用，以及 C 代码在解析ELF镜像、加载内核段中的核心逻辑，深刻理解了两者在启动阶段的协作机制；我清晰区分了实模式、保护模式与分页模式的核心差异，深入掌握了物理地址、虚拟地址、线性地址的映射关系，明确了GDT表加载对模式切换、页表初始化对地址空间管理的关键意义。
3.我在调试过程中遇到entry断点被跳过、汇编阶段日志输出失效等问题时，不再盲目尝试解决方案，而是从 “执行环境（汇编阶段无完整C运行时支撑）、指令特性（汇编代码执行速度极快）、地址类型（物理地址与虚拟地址混淆）” 三个核心维度分析根因，形成了结构化的问题排查思路；通过本次实践，我深刻认识到内核/裸机调试与应用层调试的本质区别，理解了硬件级调试对环境依赖、断点类型选择的特殊要求，实现了调试认知的升级；我在多轮环境适配、调试方案尝试失败后，能够快速调整策略，最终通过 “手动控制跳转+硬件断点” 的组合方案完成核心任务，不仅提升了问题拆解与落地能力，也培养了面对复杂问题的抗挫能力和持续优化的思维习惯。